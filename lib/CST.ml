(* Generated by ocaml-tree-sitter. *)
(*
   swift grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type multiline_comment_explicit = unit (* blank *)

type pat_f630af3 = Token.t (* pattern [^\r\n]* *)

type extended_regex_literal = Token.t (* pattern #\/((\/[^#])|[^\n])+\/# *)

type function_modifier = [
    `Infix of Token.t (* "infix" *)
  | `Post of Token.t (* "postfix" *)
  | `Prefix of Token.t (* "prefix" *)
]

type import_kind = [
    `Typeas of Token.t (* "typealias" *)
  | `Struct of Token.t (* "struct" *)
  | `Class of Token.t (* "class" *)
  | `Enum of Token.t (* "enum" *)
  | `Prot of Token.t (* "protocol" *)
  | `Let of Token.t (* "let" *)
  | `Var of Token.t (* "var" *)
  | `Func of Token.t (* "func" *)
]

type pat_c6c5536 = Token.t (* pattern #\/\n *)

type pat_c332828 = Token.t (* pattern \$[0-9]+ *)

type async_modifier = Token.t

type hex_literal = Token.t

type multiline_comment = Token.t

type real_literal = Token.t

type throws_keyword = Token.t

type pat_97d645c = Token.t (* pattern `[^\r\n` ]*` *)

type rethrows_keyword = Token.t

type raw_str_end_part = Token.t

type multi_line_str_text = Token.t (* pattern "[^\\\\\"]+" *)

type arrow_operator_custom = Token.t

type special_literal = [
    `HASH_36725ee of Token.t (* "#file" *)
  | `HASH_ee0b998 of Token.t (* "#fileID" *)
  | `HASH_bd759bd of Token.t (* "#filePath" *)
  | `HASH_709af6a of Token.t (* "#line" *)
  | `HASH_be35129 of Token.t (* "#column" *)
  | `HASH_96a7ced of Token.t (* "#function" *)
  | `HASH_4d47dbe of Token.t (* "#dsohandle" *)
]

type catch_keyword = Token.t

type bitwise_binary_operator = [
    `AMP of Token.t (* "&" *)
  | `BAR of Token.t (* "|" *)
  | `HAT of Token.t (* "^" *)
  | `LTLT of Token.t (* "<<" *)
  | `GTGT of Token.t (* ">>" *)
]

type ownership_modifier = [
    `Weak of Token.t (* "weak" *)
  | `Unow_7c8c304 of Token.t (* "unowned" *)
  | `Unow_e455cde of Token.t (* "unowned(safe)" *)
  | `Unow_8fda70e of Token.t (* "unowned(unsafe)" *)
]

type pat_88eeeaa =
  Token.t (* pattern [_\p{XID_Start}\p{Emoji}&&[^0-9#*]](\p{EMod}|\x{FE0F}\x{20E3}?)?([_\p{XID_Continue}\p{Emoji}\x{200D}](\p{EMod}|\x{FE0F}\x{20E3}?)?)* *)

type pat_27d7db1 = Token.t (* pattern (\/[^#]|[^/])*?\n\/# *)

type plus_then_ws = Token.t

type statement_label = Token.t

type async_keyword_custom = Token.t

type inheritance_modifier = [ `Final of Token.t (* "final" *) ]

type fake_try_bang = Token.t

type tok_pat_c201ddc = Token.t

type bang_custom = Token.t

type custom_operator_ = Token.t

type oct_literal = Token.t

type raw_str_continuing_indicator = Token.t

type imm_tok_qmark = Token.t (* "?" *)

type as_bang_custom = Token.t

type where_keyword = Token.t

type tok_dollar_pat_88eeeaa = Token.t

type tok_prec_n4_slash = Token.t

type comparison_operator = [
    `LT of Token.t (* "<" *)
  | `GT of Token.t (* ">" *)
  | `LTEQ of Token.t (* "<=" *)
  | `GTEQ of Token.t (* ">=" *)
]

type implicit_semi = Token.t

type property_modifier = [
    `Static of Token.t (* "static" *)
  | `Dyna of Token.t (* "dynamic" *)
  | `Opt of Token.t (* "optional" *)
  | `Class of Token.t (* "class" *)
  | `Dist of Token.t (* "distributed" *)
]

type imm_tok_bang = Token.t (* "!" *)

type minus_then_ws = Token.t

type explicit_semi = Token.t

type semgrep_ellipsis_metavar =
  Token.t (* pattern \$\.\.\.[a-zA-Z_][a-zA-Z_0-9]* *)

type boolean_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]

type escaped_identifier = Token.t (* pattern "\\\\[0\\\\tnr\"'\\n]" *)

type member_modifier = [
    `Over of Token.t (* "override" *)
  | `Conv of Token.t (* "convenience" *)
  | `Requ of Token.t (* "required" *)
  | `Noni of Token.t (* "nonisolated" *)
]

type eq_eq_custom = Token.t

type oneline_regex_literal = Token.t

type raw_str_part = Token.t

type parameter_ownership_modifier = [
    `Borr of Token.t (* "borrowing" *)
  | `Cons of Token.t (* "consuming" *)
]

type pat_888b548 = Token.t (* pattern \{[0-9a-fA-F]+\} *)

type default_keyword = Token.t

type disjunction_operator_custom = Token.t

type integer_literal = Token.t

type optionally_valueful_control_keyword = [
    `Ret of Token.t (* "return" *)
  | `Cont of Token.t (* "continue" *)
  | `Brk of Token.t (* "break" *)
  | `Yield of Token.t (* "yield" *)
]

type raw_str_interpolation_start = Token.t (* pattern \\#*\( *)

type else_ = Token.t

type as_quest_custom = Token.t

type eq_custom = Token.t

type value_binding_pattern = [
    `Var of Token.t (* "var" *)
  | `Let of Token.t (* "let" *)
]

type dot_custom = Token.t

type line_str_text = Token.t (* pattern "[^\\\\\"]+" *)

type mutation_modifier = [
    `Muta of Token.t (* "mutating" *)
  | `Nonm of Token.t (* "nonmutating" *)
]

type as_custom = Token.t

type conjunction_operator_custom = Token.t

type nil_coalescing_operator_custom = Token.t

type bin_literal = Token.t

type shebang_line = (Token.t (* "#!" *) * pat_f630af3)

type throws = [
    `Throws_kw of throws_keyword (*tok*)
  | `Rethrs_kw of rethrows_keyword (*tok*)
]

type bang = [
    `Bang_custom of bang_custom (*tok*)
  | `BANG of Token.t (* "!" *)
]

type custom_operator = [
    `Tok_pat_c201ddc of tok_pat_c201ddc (*tok*)
  | `Custom_op_ of custom_operator_ (*tok*)
]

type multiplicative_operator = [
    `STAR of Token.t (* "*" *)
  | `Tok_prec_n4_slash of tok_prec_n4_slash (*tok*)
  | `PERC of Token.t (* "%" *)
]

type try_operator_type = [
    `Imm_tok_bang of imm_tok_bang (*tok*)
  | `Imm_tok_qmark of imm_tok_qmark (*tok*)
]

type additive_operator = [
    `Plus_then_ws of plus_then_ws (*tok*)
  | `Minus_then_ws of minus_then_ws (*tok*)
  | `PLUS of Token.t (* "+" *)
  | `DASH of Token.t (* "-" *)
]

type locally_permitted_modifier = [
    `Owne_modi of ownership_modifier
  | `Inhe_modi of inheritance_modifier
  | `Prop_beha_modi of Token.t (* "lazy" *)
]

type semi = [
    `Impl_semi of implicit_semi (*tok*)
  | `Expl_semi of explicit_semi (*tok*)
]

type contextual_simple_identifier = [
    `Actor of Token.t (* "actor" *)
  | `Async of Token.t (* "async" *)
  | `Each of Token.t (* "each" *)
  | `Lazy of Token.t (* "lazy" *)
  | `Repeat of Token.t (* "repeat" *)
  | `Pack of Token.t (* "package" *)
  | `Param_owne_modi of parameter_ownership_modifier
]

type parameter_modifier = [
    `Inout of Token.t (* "inout" *)
  | `ATes of Token.t (* "@escaping" *)
  | `ATau of Token.t (* "@autoclosure" *)
  | `Param_owne_modi of parameter_ownership_modifier
]

type range_operator = [
    `Open_ended_range_op of Token.t (* "..<" *)
  | `Three_dot_op of Token.t (* "..." *)
]

type possibly_async_binding_pattern_kind = (
    async_modifier (*tok*) option
  * value_binding_pattern
)

type setter_specifier = (mutation_modifier option * Token.t (* "set" *))

type modify_specifier = (mutation_modifier option * Token.t (* "_modify" *))

type regex_literal = [
    `Exte_regex_lit of extended_regex_literal (*tok*)
  | `Mult_regex_lit of (pat_c6c5536 * pat_27d7db1)
  | `Onel_regex_lit of oneline_regex_literal (*tok*)
]

type getter_effects =
  [ `Async_kw of async_keyword_custom (*tok*) | `Throws of throws ]
    list (* one or more *)

type postfix_unary_operator = [
    `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `Bang of bang
]

type try_operator = (
    Token.t (* "try" *)
  * [
        `Opt_try_op_type of try_operator_type option
      | `Fake_try_bang of fake_try_bang (*tok*)
    ]
)

type class_member_separator = [
    `Semi of semi
  | `Mult_comm_expl of multiline_comment_explicit (*tok*)
]

type equality_operator = [
    `BANGEQ of Token.t (* "!=" *)
  | `BANGEQEQ of Token.t (* "!==" *)
  | `Eq_eq of eq_eq_custom (*tok*)
  | `EQEQEQ of Token.t (* "===" *)
]

type simple_identifier = [
    `Pat_88eeeaa of pat_88eeeaa
  | `Pat_97d645c of pat_97d645c
  | `Pat_c332828 of pat_c332828
  | `Tok_dollar_pat_88eeeaa of tok_dollar_pat_88eeeaa
  | `Cont_simple_id of contextual_simple_identifier
]

type non_local_scope_modifier = [
    `Member_modi of member_modifier
  | `Visi_modi of (
        [
            `Public of Token.t (* "public" *)
          | `Priv of Token.t (* "private" *)
          | `Inte of Token.t (* "internal" *)
          | `File of Token.t (* "fileprivate" *)
          | `Open of Token.t (* "open" *)
          | `Pack of Token.t (* "package" *)
        ]
      * (Token.t (* "(" *) * Token.t (* "set" *) * Token.t (* ")" *)) option
    )
  | `Func_modi of function_modifier
  | `Muta_modi of mutation_modifier
  | `Prop_modi of property_modifier
  | `Param_modi of parameter_modifier
]

type parameter_modifiers = parameter_modifier list (* one or more *)

type str_escaped_char = [
    `Esca_id of escaped_identifier (*tok*)
  | `Uni_char_lit of (Token.t (* "\\" *) * Token.t (* "u" *) * pat_888b548)
]

type assignment_and_operator = [
    `PLUSEQ of Token.t (* "+=" *)
  | `DASHEQ of Token.t (* "-=" *)
  | `STAREQ of Token.t (* "*=" *)
  | `SLASHEQ of Token.t (* "/=" *)
  | `PERCEQ of Token.t (* "%=" *)
  | `Equal_sign of eq_custom (*tok*)
]

type prefix_unary_operator = [
    `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `DASH of Token.t (* "-" *)
  | `PLUS of Token.t (* "+" *)
  | `Bang of bang
  | `AMP of Token.t (* "&" *)
  | `TILDE of Token.t (* "~" *)
  | `Dot of dot_custom (*tok*)
  | `Custom_op of custom_operator
]

type as_operator = [
    `As of as_custom (*tok*)
  | `As_quest of as_quest_custom (*tok*)
  | `As_bang of as_bang_custom (*tok*)
]

type getter_specifier = (
    mutation_modifier option
  * Token.t (* "get" *)
  * getter_effects option
)

type bound_identifier = simple_identifier

type multi_line_string_content = [
    `Multi_line_str_text of multi_line_str_text (*tok*)
  | `Str_esca_char of str_escaped_char
  | `DQUOT of Token.t (* "\"" *)
]

type line_string_content = [
    `Line_str_text of line_str_text (*tok*)
  | `Str_esca_char of str_escaped_char
]

type referenceable_operator = [
    `Custom_op of custom_operator
  | `Comp_op of comparison_operator
  | `Addi_op of additive_operator
  | `Mult_op of multiplicative_operator
  | `Equa_op of equality_operator
  | `Assign_and_op of assignment_and_operator
  | `PLUSPLUS of Token.t (* "++" *)
  | `DASHDASH of Token.t (* "--" *)
  | `Bang of bang
  | `TILDE of Token.t (* "~" *)
  | `BAR of Token.t (* "|" *)
  | `HAT of Token.t (* "^" *)
  | `LTLT of Token.t (* "<<" *)
  | `GTGT of Token.t (* ">>" *)
  | `AMP of Token.t (* "&" *)
]

type protocol_property_requirements = (
    Token.t (* "{" *)
  * [ `Getter_spec of getter_specifier | `Setter_spec of setter_specifier ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

type precedence_group_attribute = (
    bound_identifier
  * Token.t (* ":" *)
  * [ `Simple_id of bound_identifier | `Bool_lit of boolean_literal ]
)

type value_argument_label = [
    `Simple_id of bound_identifier
  | `If of Token.t (* "if" *)
  | `Switch of Token.t (* "switch" *)
]

type identifier = (
    bound_identifier
  * (dot_custom (*tok*) * bound_identifier) list (* zero or more *)
)

type navigation_suffix = [
    `Dot_choice_simple_id of (
        dot_custom (*tok*)
      * [
            `Simple_id of bound_identifier
          | `Int_lit of integer_literal (*tok*)
        ]
    )
  | `Dot_semg_ellips of (dot_custom (*tok*) * Token.t (* "..." *))
]

type tuple_type_item_identifier = (
    Token.t (* "_" *) option
  * bound_identifier
  * Token.t (* ":" *)
)

type non_constructor_function_decl = (
    Token.t (* "func" *)
  * [ `Simple_id of bound_identifier | `Refe_op of referenceable_operator ]
)

type precedence_group_attributes =
  precedence_group_attribute list (* one or more *)

type availability_argument = [
    `Id_int_lit_rep_DOT_int_lit of (
        identifier
      * integer_literal (*tok*)
      * (Token.t (* "." *) * integer_literal (*tok*)) list (* zero or more *)
    )
  | `STAR of Token.t (* "*" *)
]

type precedence_group_declaration = (
    Token.t (* "precedencegroup" *)
  * bound_identifier
  * Token.t (* "{" *)
  * precedence_group_attributes option
  * Token.t (* "}" *)
)

type annotated_inheritance_specifier = (
    attribute list (* zero or more *)
  * inheritance_specifier
)

and array_type = (Token.t (* "[" *) * type_ * Token.t (* "]" *))

and assignment = (
    directly_assignable_expression * assignment_and_operator
  * directly_assignable_expression
)

and associatedtype_declaration = (
    modifiers option
  * Token.t (* "associatedtype" *)
  * bound_identifier
  * (Token.t (* ":" *) * type_) option
  * type_constraints option
  * (eq_custom (*tok*) * type_) option
)

and attribute = (
    Token.t (* "@" *)
  * user_type
  * (
        Token.t (* "(" *)
      * attribute_argument
      * (Token.t (* "," *) * attribute_argument) list (* zero or more *)
      * Token.t (* ")" *)
    )
      option
)

and attribute_argument = [
    `Simple_id_COLON_exp of (
        bound_identifier * Token.t (* ":" *) * directly_assignable_expression
    )
  | `Exp of directly_assignable_expression
  | `Rep1_simple_id_COLON of
      (bound_identifier * Token.t (* ":" *)) list (* one or more *)
  | `Rep1_simple_id_int_lit_rep_DOT_int_lit of (
        bound_identifier list (* one or more *)
      * integer_literal (*tok*)
      * (Token.t (* "." *) * integer_literal (*tok*)) list (* zero or more *)
    )
]

and basic_literal = [
    `Int_lit of integer_literal (*tok*)
  | `Hex_lit of hex_literal (*tok*)
  | `Oct_lit of oct_literal (*tok*)
  | `Bin_lit of bin_literal (*tok*)
  | `Real_lit of real_literal (*tok*)
  | `Bool_lit of boolean_literal
  | `Str_lit of string_literal
  | `Regex_lit of regex_literal
  | `Nil of Token.t (* "nil" *)
]

and binary_expression = [
    `Mult_exp of (
        directly_assignable_expression * multiplicative_operator
      * directly_assignable_expression
    )
  | `Addi_exp of (
        directly_assignable_expression * additive_operator
      * directly_assignable_expression
    )
  | `Range_exp of (
        directly_assignable_expression * range_operator
      * expr_hack_at_ternary_binary_suffix
    )
  | `Infix_exp of (
        directly_assignable_expression * custom_operator
      * expr_hack_at_ternary_binary_suffix
    )
  | `Nil_coal_exp of (
        directly_assignable_expression
      * nil_coalescing_operator_custom (*tok*)
      * expr_hack_at_ternary_binary_suffix
    )
  | `Check_exp of (
        directly_assignable_expression * Token.t (* "is" *) * type_
    )
  | `Equa_exp of (
        directly_assignable_expression * equality_operator
      * expr_hack_at_ternary_binary_suffix
    )
  | `Comp_exp of (
        directly_assignable_expression * comparison_operator
      * expr_hack_at_ternary_binary_suffix
    )
  | `Conj_exp of (
        directly_assignable_expression * conjunction_operator_custom (*tok*)
      * expr_hack_at_ternary_binary_suffix
    )
  | `Disj_exp of (
        directly_assignable_expression * disjunction_operator_custom (*tok*)
      * expr_hack_at_ternary_binary_suffix
    )
  | `Bitw_oper of (
        directly_assignable_expression * bitwise_binary_operator
      * expr_hack_at_ternary_binary_suffix
    )
]

and binding_kind_and_pattern = (
    possibly_async_binding_pattern_kind * no_expr_pattern_already_bound
)

and binding_pattern = (
    Token.t (* "case" *) option
  * value_binding_pattern
  * no_expr_pattern_already_bound
)

and binding_pattern_no_expr = (
    [
        `Univ_allo_pat of universally_allowed_pattern
      | `Bind_pat of binding_pattern
      | `Bound_id of bound_identifier
    ]
  * Token.t (* "?" *) option
)

and binding_pattern_with_expr = (
    [
        `Univ_allo_pat of universally_allowed_pattern
      | `Bind_pat of binding_pattern
      | `Exp of directly_assignable_expression
    ]
  * Token.t (* "?" *) option
)

and block = (Token.t (* "{" *) * statements option * Token.t (* "}" *))

and bodyless_function_declaration = (
    modifiers option
  * Token.t (* "class" *) option
  * modifierless_function_declaration_no_body
)

and call_expression = (directly_assignable_expression * call_suffix)

and call_suffix = [
    `Value_args of expr_hack_at_ternary_binary_call_suffix
  | `Fn_call_lambda_args of fn_call_lambda_arguments
  | `Value_args_fn_call_lambda_args of (
        expr_hack_at_ternary_binary_call_suffix * fn_call_lambda_arguments
    )
]

and capture_list = (
    Token.t (* "[" *)
  * capture_list_item
  * (Token.t (* "," *) * capture_list_item) list (* zero or more *)
  * Token.t (* "]" *)
)

and capture_list_item = [
    `Self_exp of Token.t (* "self" *)
  | `Opt_owne_modi_simple_id_opt_equal_sign_exp of (
        ownership_modifier option
      * bound_identifier
      * expression_without_willset_didset option
    )
]

and catch_block = (
    catch_keyword (*tok*)
  * binding_pattern_no_expr option
  * where_clause option
  * function_body
)

and class_body = (
    Token.t (* "{" *)
  * class_member_declarations option
  * Token.t (* "}" *)
)

and class_declaration = (modifiers option * modifierless_class_declaration)

and class_member_declarations = (
    type_level_declaration
  * (class_member_separator * type_level_declaration) list (* zero or more *)
  * class_member_separator option
)

and computed_getter = (
    attribute list (* zero or more *)
  * getter_specifier
  * function_body option
)

and computed_modify = (
    attribute list (* zero or more *)
  * modify_specifier
  * function_body option
)

and computed_property = (
    Token.t (* "{" *)
  * [
        `Opt_stmts of statements option
      | `Rep_choice_comp_getter of
          [
              `Comp_getter of computed_getter
            | `Comp_setter of computed_setter
            | `Comp_modify of computed_modify
          ]
            list (* zero or more *)
    ]
  * Token.t (* "}" *)
)

and computed_setter = (
    attribute list (* zero or more *)
  * setter_specifier
  * (Token.t (* "(" *) * bound_identifier * Token.t (* ")" *)) option
  * function_body option
)

and constrained_type = [
    `Id of identifier
  | `Unan_type_opt_DOT_simple_id_rep_DOT_simple_id of (
        unannotated_type
      * (
            Token.t (* "." *)
          * bound_identifier
          * (Token.t (* "." *) * bound_identifier) list (* zero or more *)
        )
          option
    )
]

and constructor_suffix = [
    `Cons_value_args of constructor_value_arguments
  | `Fn_call_lambda_args of fn_call_lambda_arguments
  | `Cons_value_args_fn_call_lambda_args of (
        constructor_value_arguments * fn_call_lambda_arguments
    )
]

and constructor_value_arguments = (
    Token.t (* "(" *)
  * interpolation_contents option
  * Token.t (* ")" *)
)

and control_transfer_statement = [
    `Throw_stmt of throw_statement
  | `Opti_valu_cont_kw_opt_exp of (
        optionally_valueful_control_keyword
      * directly_assignable_expression option
    )
]

and deinit_declaration = (
    modifiers option
  * Token.t (* "deinit" *)
  * function_body
)

and deprecated_operator_declaration_body = (
    Token.t (* "{" *)
  * [ `Simple_id of bound_identifier | `Basic_lit of basic_literal ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and dictionary_literal_item = (
    directly_assignable_expression * Token.t (* ":" *)
  * directly_assignable_expression
)

and dictionary_type = (
    Token.t (* "[" *) * type_ * Token.t (* ":" *) * type_ * Token.t (* "]" *)
)

and didset_clause = (
    modifiers option
  * Token.t (* "didSet" *)
  * (Token.t (* "(" *) * bound_identifier * Token.t (* ")" *)) option
  * function_body
)

and direct_or_indirect_binding = (
    [
        `Bind_kind_and_pat of binding_kind_and_pattern
      | `Case_bind_pat_no_expr of (
            Token.t (* "case" *) * binding_pattern_no_expr
        )
    ]
  * type_annotation option
)

and directly_assignable_expression = expression

and do_statement = (
    Token.t (* "do" *)
  * function_body
  * catch_block list (* zero or more *)
)

and else_options = [ `Blk of function_body | `If_stmt of if_statement ]

and enum_class_body = (
    Token.t (* "{" *)
  * [
        `Enum_entry of enum_entry
      | `Type_level_decl of type_level_declaration
    ]
      list (* zero or more *)
  * Token.t (* "}" *)
)

and enum_entry = (
    modifiers option
  * Token.t (* "indirect" *) option
  * Token.t (* "case" *)
  * bound_identifier
  * enum_entry_suffix option
  * (Token.t (* "," *) * bound_identifier * enum_entry_suffix option)
      list (* zero or more *)
  * Token.t (* ";" *) option
)

and enum_entry_suffix = [
    `Enum_type_params of (
        Token.t (* "(" *)
      * (
            tuple_type_item_identifier option
          * type_
          * expression_without_willset_didset option
          * (
                Token.t (* "," *)
              * tuple_type_item_identifier option
              * type_
              * expression_without_willset_didset option
            )
              list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
    )
  | `Equal_sign_exp of expression_without_willset_didset
]

and existential_type = (Token.t (* "any" *) * unannotated_type)

and expr_hack_at_ternary_binary_call_suffix = value_arguments

and expr_hack_at_ternary_binary_suffix = [
    `Exp of directly_assignable_expression
  | `Expr_hack_at_tern_bin_call of (
        directly_assignable_expression
      * expr_hack_at_ternary_binary_call_suffix
    )
]

and expression = [
    `Choice_simple_id of [
        `Simple_id of bound_identifier
      | `Un_exp of unary_expression
      | `Bin_exp of binary_expression
      | `Tern_exp of ternary_expression
      | `Prim_exp of primary_expression
      | `If_stmt of if_statement
      | `Switch_stmt of switch_statement
      | `Assign of assignment
      | `Value_param_pack of value_parameter_pack
      | `Value_pack_expa of value_pack_expansion
      | `Exp_imme_quest of (
            directly_assignable_expression * Token.t (* "?" *)
        )
    ]
  | `Semg_exp_ellips of Token.t (* "..." *)
  | `Semg_ellips_meta of semgrep_ellipsis_metavar (*tok*)
  | `Semg_deep_ellips of (
        Token.t (* "<..." *) * directly_assignable_expression
      * custom_operator
    )
]

and expression_with_willset_didset = (
    eq_custom (*tok*) * directly_assignable_expression * willset_didset_block
)

and expression_without_willset_didset = (
    eq_custom (*tok*) * directly_assignable_expression
)

and fn_call_lambda_arguments = (
    lambda_literal
  * (bound_identifier * Token.t (* ":" *) * lambda_literal)
      list (* zero or more *)
)

and for_statement = (
    Token.t (* "for" *)
  * try_operator option
  * Token.t (* "await" *) option
  * binding_pattern_no_expr
  * type_annotation option
  * Token.t (* "in" *)
  * for_statement_collection
  * where_clause option
  * function_body
)

and for_statement_collection = [
    `Exp of directly_assignable_expression
  | `For_stmt_await of (
        Token.t (* "await" *) * directly_assignable_expression
    )
]

and function_body = block

and function_declaration = (bodyless_function_declaration * function_body)

and function_type = (
    [ `Tuple_type of tuple_type | `Unan_type of unannotated_type ]
  * async_keyword_custom (*tok*) option
  * throws option
  * arrow_operator_custom (*tok*)
  * type_
)

and function_value_parameter = (
    attribute option
  * parameter
  * expression_without_willset_didset option
)

and function_value_parameters =
  (
      Token.t (* "(" *)
    * (
          function_value_parameter
        * (Token.t (* "," *) * function_value_parameter)
            list (* zero or more *)
      )
        option
    * Token.t (* ")" *)
  )
    list (* one or more *)

and guard_statement = (
    Token.t (* "guard" *)
  * if_condition_sequence_item
  * (Token.t (* "," *) * if_condition_sequence_item) list (* zero or more *)
  * else_ (*tok*)
  * function_body
)

and if_condition_sequence_item = [
    `If_let_bind of (
        direct_or_indirect_binding
      * expression_without_willset_didset option
      * where_clause option
    )
  | `Exp of directly_assignable_expression
  | `Avai_cond of (
        [
            `HASH_8da4fa1 of Token.t (* "#available" *)
          | `HASH_459dd9a of Token.t (* "#unavailable" *)
        ]
      * Token.t (* "(" *)
      * availability_argument
      * (Token.t (* "," *) * availability_argument) list (* zero or more *)
      * Token.t (* ")" *)
    )
]

and if_statement = (
    Token.t (* "if" *)
  * if_condition_sequence_item
  * (Token.t (* "," *) * if_condition_sequence_item) list (* zero or more *)
  * function_body
  * (else_ (*tok*) * else_options) option
)

and import_declaration = (
    modifiers option
  * Token.t (* "import" *)
  * import_kind option
  * identifier
)

and inheritance_specifier = [
    `User_type of user_type
  | `Func_type of function_type
]

and inheritance_specifiers = (
    annotated_inheritance_specifier
  * (
        [ `COMMA of Token.t (* "," *) | `AMP of Token.t (* "&" *) ]
      * annotated_inheritance_specifier
    )
      list (* zero or more *)
)

and init_declaration = (
    modifiers option
  * Token.t (* "class" *) option
  * Token.t (* "init" *)
  * [ `Quest of Token.t (* "?" *) | `Bang of bang ] option
  * type_parameters option
  * function_value_parameters
  * async_keyword_custom (*tok*) option
  * throws option
  * type_constraints option
  * function_body option
)

and interpolation = (
    Token.t (* "\\(" *) * interpolation_contents * Token.t (* ")" *)
)

and interpolation_contents = (
    value_argument
  * (Token.t (* "," *) * value_argument) list (* zero or more *)
)

and key_path_component = [
    `Simple_id_rep_key_path_postfs of (
        bound_identifier
      * key_path_postfixes list (* zero or more *)
    )
  | `Rep1_key_path_postfs of key_path_postfixes list (* one or more *)
]

and key_path_postfixes = [
    `QMARK of Token.t (* "?" *)
  | `Bang of bang
  | `Self of Token.t (* "self" *)
  | `LBRACK_opt_value_arg_rep_COMMA_value_arg_RBRACK of (
        Token.t (* "[" *)
      * interpolation_contents option
      * Token.t (* "]" *)
    )
]

and labeled_statement = (
    statement_label (*tok*) option
  * [
        `For_stmt of for_statement
      | `While_stmt of while_statement
      | `Repeat_while_stmt of repeat_while_statement
      | `Do_stmt of do_statement
      | `If_stmt of if_statement
      | `Guard_stmt of guard_statement
      | `Switch_stmt of switch_statement
    ]
)

and lambda_function_type = (
    [
        `Lambda_func_type_params of lambda_function_type_parameters
      | `LPAR_opt_lambda_func_type_params_RPAR of (
            Token.t (* "(" *)
          * lambda_function_type_parameters option
          * Token.t (* ")" *)
        )
    ]
  * async_keyword_custom (*tok*) option
  * throws option
  * (arrow_operator_custom (*tok*) * possibly_implicitly_unwrapped_type)
      option
)

and lambda_function_type_parameters = (
    lambda_parameter
  * (Token.t (* "," *) * lambda_parameter) list (* zero or more *)
)

and lambda_literal = (
    [ `LCURL of Token.t (* "{" *) | `HATLCURL of Token.t (* "^{" *) ]
  * lambda_type_declaration option
  * statements option
  * Token.t (* "}" *)
)

and lambda_parameter = [
    `Self_exp of Token.t (* "self" *)
  | `Simple_id of bound_identifier
  | `Opt_simple_id_simple_id_COLON_opt_param_modifs_poss_impl_unwr_type of (
        bound_identifier option
      * bound_identifier
      * Token.t (* ":" *)
      * parameter_modifiers option
      * possibly_implicitly_unwrapped_type
    )
]

and lambda_type_declaration = (
    attribute list (* zero or more *)
  * capture_list option
  * lambda_function_type option
  * Token.t (* "in" *)
)

and local_declaration = [
    `Local_prop_decl of (
        locally_permitted_modifiers option
      * modifierless_property_declaration
    )
  | `Local_typeas_decl of (
        locally_permitted_modifiers option
      * modifierless_typealias_declaration
    )
  | `Local_func_decl of (
        locally_permitted_modifiers option
      * modifierless_function_declaration
    )
  | `Local_class_decl of (
        locally_permitted_modifiers option
      * modifierless_class_declaration
    )
]

and local_statement = [
    `Exp of directly_assignable_expression
  | `Local_decl of local_declaration
  | `Labe_stmt of labeled_statement
  | `Cont_tran_stmt of control_transfer_statement
]

and locally_permitted_modifiers =
  [ `Attr of attribute | `Loca_perm_modi of locally_permitted_modifier ]
    list (* one or more *)

and modifierless_class_declaration = [
    `Choice_class_simple_id_opt_type_params_opt_COLON_inhe_specis_opt_type_consts_class_body of (
        [
            `Class of Token.t (* "class" *)
          | `Struct of Token.t (* "struct" *)
          | `Actor of Token.t (* "actor" *)
        ]
      * bound_identifier
      * type_parameters option
      * (Token.t (* ":" *) * inheritance_specifiers) option
      * type_constraints option
      * class_body
    )
  | `Exte_unan_type_opt_type_params_opt_COLON_inhe_specis_opt_type_consts_class_body of (
        Token.t (* "extension" *)
      * unannotated_type
      * type_parameters option
      * (Token.t (* ":" *) * inheritance_specifiers) option
      * type_constraints option
      * class_body
    )
  | `Opt_indi_enum_simple_id_opt_type_params_opt_COLON_inhe_specis_opt_type_consts_enum_class_body of (
        Token.t (* "indirect" *) option
      * Token.t (* "enum" *)
      * bound_identifier
      * type_parameters option
      * (Token.t (* ":" *) * inheritance_specifiers) option
      * type_constraints option
      * enum_class_body
    )
]

and modifierless_function_declaration = (
    modifierless_function_declaration_no_body * function_body
)

and modifierless_function_declaration_no_body = (
    non_constructor_function_decl
  * type_parameters option
  * function_value_parameters
  * async_keyword_custom (*tok*) option
  * throws option
  * (arrow_operator_custom (*tok*) * possibly_implicitly_unwrapped_type)
      option
  * type_constraints option
)

and modifierless_property_declaration = (
    possibly_async_binding_pattern_kind
  * single_modifierless_property_declaration
  * (Token.t (* "," *) * single_modifierless_property_declaration)
      list (* zero or more *)
)

and modifierless_typealias_declaration = (
    Token.t (* "typealias" *)
  * bound_identifier
  * type_parameters option
  * eq_custom (*tok*)
  * type_
)

and modifiers =
  [
      `Non_local_scope_modi of non_local_scope_modifier
    | `Rep1_choice_attr of locally_permitted_modifiers
  ]
    list (* one or more *)

and navigable_type_expression = [
    `User_type of user_type
  | `Array_type of array_type
  | `Dict_type of dictionary_type
]

and no_expr_pattern_already_bound = (
    [
        `Univ_allo_pat of universally_allowed_pattern
      | `Bound_id of bound_identifier
    ]
  * Token.t (* "?" *) option
)

and opaque_type = (Token.t (* "some" *) * unannotated_type)

and operator_declaration = (
    [
        `Prefix of Token.t (* "prefix" *)
      | `Infix of Token.t (* "infix" *)
      | `Post of Token.t (* "postfix" *)
    ]
  * Token.t (* "operator" *)
  * referenceable_operator
  * (Token.t (* ":" *) * bound_identifier) option
  * deprecated_operator_declaration_body option
)

and parameter = [
    `Opt_simple_id_simple_id_COLON_opt_param_modifs_poss_impl_unwr_type_opt_three_dot_op of (
        bound_identifier option
      * bound_identifier
      * Token.t (* ":" *)
      * parameter_modifiers option
      * possibly_implicitly_unwrapped_type
      * Token.t (* "..." *) option
    )
  | `Semg_ellips of Token.t (* "..." *)
  | `Semg_ellips_meta of semgrep_ellipsis_metavar (*tok*)
]

and parenthesized_type = (
    Token.t (* "(" *)
  * [
        `Opaque_type of opaque_type
      | `Exis_type of existential_type
      | `Dict_type of dictionary_type
    ]
  * Token.t (* ")" *)
)

and possibly_implicitly_unwrapped_type = (
    type_
  * imm_tok_bang (*tok*) option
)

and primary_expression = [
    `Tuple_exp of (
        Token.t (* "(" *)
      * (bound_identifier * Token.t (* ":" *)) option
      * directly_assignable_expression
      * (
            Token.t (* "," *)
          * (bound_identifier * Token.t (* ":" *)) option
          * directly_assignable_expression
        )
          list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `Basic_lit of basic_literal
  | `Lambda_lit of lambda_literal
  | `Spec_lit of special_literal
  | `Play_lit of (
        [
            `HASH_38ce0d0 of Token.t (* "#colorLiteral" *)
          | `HASH_34ae46a of Token.t (* "#fileLiteral" *)
          | `HASH_71f9c0e of Token.t (* "#imageLiteral" *)
        ]
      * Token.t (* "(" *)
      * bound_identifier
      * Token.t (* ":" *)
      * directly_assignable_expression
      * (
            Token.t (* "," *) * bound_identifier * Token.t (* ":" *)
          * directly_assignable_expression
        )
          list (* zero or more *)
      * Token.t (* ")" *)
    )
  | `Array_lit of (
        Token.t (* "[" *)
      * (
            directly_assignable_expression
          * (Token.t (* "," *) * directly_assignable_expression)
              list (* zero or more *)
        )
          option
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
  | `Dict_lit of (
        Token.t (* "[" *)
      * [
            `COLON of Token.t (* ":" *)
          | `Dict_lit_item_rep_COMMA_dict_lit_item of (
                dictionary_literal_item
              * (Token.t (* "," *) * dictionary_literal_item)
                  list (* zero or more *)
            )
        ]
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
  | `Self_exp of Token.t (* "self" *)
  | `Super_exp of Token.t (* "super" *)
  | `Try_exp of (
        try_operator
      * [
            `Exp of directly_assignable_expression
          | `Bin_exp of binary_expression
          | `Call_exp of call_expression
          | `Tern_exp of ternary_expression
        ]
    )
  | `Await_exp of (
        Token.t (* "await" *)
      * [
            `Exp of directly_assignable_expression
          | `Call_exp of call_expression
          | `Tern_exp of ternary_expression
        ]
    )
  | `Refe_op of referenceable_operator
  | `Key_path_exp of (
        Token.t (* "\\" *)
      * [
            `Simple_user_type of simple_user_type
          | `Array_type of array_type
          | `Dict_type of dictionary_type
        ]
          option
      * (Token.t (* "." *) * key_path_component) list (* zero or more *)
    )
  | `Key_path_str_exp of (
        Token.t (* "#keyPath" *) * Token.t (* "(" *)
      * directly_assignable_expression * Token.t (* ")" *)
    )
  | `Three_dot_op of Token.t (* "..." *)
]

and property_declaration = (
    modifiers option
  * modifierless_property_declaration
)

and protocol_body = (
    Token.t (* "{" *)
  * protocol_member_declarations option
  * Token.t (* "}" *)
)

and protocol_declaration = (
    modifiers option
  * Token.t (* "protocol" *)
  * bound_identifier
  * type_parameters option
  * (Token.t (* ":" *) * inheritance_specifiers) option
  * type_constraints option
  * protocol_body
)

and protocol_member_declaration = [
    `Body_func_decl_opt_func_body of (
        bodyless_function_declaration
      * function_body option
    )
  | `Init_decl of init_declaration
  | `Deinit_decl of deinit_declaration
  | `Prot_prop_decl of (
        modifiers option
      * binding_kind_and_pattern
      * type_annotation option
      * type_constraints option
      * protocol_property_requirements
    )
  | `Typeas_decl of typealias_declaration
  | `Asso_decl of associatedtype_declaration
  | `Subs_decl of subscript_declaration
]

and protocol_member_declarations = (
    protocol_member_declaration
  * (semi * protocol_member_declaration) list (* zero or more *)
  * semi option
)

and raw_str_interpolation = (
    raw_str_interpolation_start (*tok*) * interpolation_contents
  * Token.t (* ")" *)
)

and repeat_while_statement = (
    Token.t (* "repeat" *)
  * Token.t (* "{" *)
  * statements option
  * Token.t (* "}" *)
  * implicit_semi (*tok*) list (* zero or more *)
  * Token.t (* "while" *)
  * if_condition_sequence_item
  * (Token.t (* "," *) * if_condition_sequence_item) list (* zero or more *)
)

and simple_user_type = (bound_identifier * type_arguments option)

and single_modifierless_property_declaration = (
    no_expr_pattern_already_bound
  * type_annotation option
  * type_constraints option
  * [
        `Exp_with_will_didset_6031240 of expression_with_willset_didset
      | `Exp_with_will_didset_3bae343 of expression_without_willset_didset
      | `Will_didset_blk of willset_didset_block
      | `Comp_prop of computed_property
    ]
      option
)

and statements = (
    local_statement
  * (semi * local_statement) list (* zero or more *)
  * semi option
)

and string_literal = [
    `Line_str_lit of (
        Token.t (* "\"" *)
      * [
            `Line_str_content of line_string_content
          | `Interp of interpolation
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
  | `Multi_line_str_lit of (
        Token.t (* "\"\"\"" *)
      * [
            `Multi_line_str_content of multi_line_string_content
          | `Interp of interpolation
        ]
          list (* zero or more *)
      * Token.t (* "\"\"\"" *)
    )
  | `Raw_str_lit of (
        (
            raw_str_part (*tok*)
          * raw_str_interpolation
          * raw_str_continuing_indicator (*tok*) option
        )
          list (* zero or more *)
      * raw_str_end_part (*tok*)
    )
]

and subscript_declaration = (
    modifiers option
  * Token.t (* "subscript" *)
  * type_parameters option
  * function_value_parameters
  * (arrow_operator_custom (*tok*) * possibly_implicitly_unwrapped_type)
      option
  * type_constraints option
  * computed_property
)

and switch_entry = (
    modifiers option
  * [
        `Case_switch_pat_opt_where_kw_exp_rep_COMMA_switch_pat of (
            Token.t (* "case" *)
          * switch_pattern
          * where_clause option
          * (Token.t (* "," *) * switch_pattern) list (* zero or more *)
        )
      | `Defa_kw of default_keyword (*tok*)
    ]
  * Token.t (* ":" *)
  * statements
  * Token.t (* "fallthrough" *) option
)

and switch_pattern = binding_pattern_with_expr

and switch_statement = (
    Token.t (* "switch" *)
  * directly_assignable_expression
  * Token.t (* "{" *)
  * switch_entry list (* zero or more *)
  * Token.t (* "}" *)
)

and ternary_expression = (
    directly_assignable_expression * Token.t (* "?" *)
  * directly_assignable_expression * Token.t (* ":" *)
  * expr_hack_at_ternary_binary_suffix
)

and throw_statement = (
    Token.t (* "throw" *) * directly_assignable_expression
)

and tuple_pattern = (
    Token.t (* "(" *)
  * tuple_pattern_item
  * (Token.t (* "," *) * tuple_pattern_item) list (* zero or more *)
  * Token.t (* ")" *)
)

and tuple_pattern_item = [
    `Simple_id_COLON_bind_pat_with_expr of (
        bound_identifier * Token.t (* ":" *) * switch_pattern
    )
  | `Bind_pat_with_expr of switch_pattern
]

and tuple_type = [
    `LPAR_opt_tuple_type_item_rep_COMMA_tuple_type_item_RPAR of (
        Token.t (* "(" *)
      * (
            tuple_type_item
          * (Token.t (* "," *) * tuple_type_item) list (* zero or more *)
        )
          option
      * Token.t (* ")" *)
    )
  | `Paren_type of parenthesized_type
]

and tuple_type_item = (
    tuple_type_item_identifier option
  * parameter_modifiers option
  * type_
)

and type_ = [
    `Opt_type_modifs_unan_type of (type_modifiers option * unannotated_type)
  | `Semg_ellips of Token.t (* "..." *)
]

and type_annotation = (
    Token.t (* ":" *) * possibly_implicitly_unwrapped_type
)

and type_arguments = (
    Token.t (* "<" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)
  * Token.t (* ">" *)
)

and type_casting_pattern = [
    `Is_type of (Token.t (* "is" *) * type_)
  | `Bind_pat_no_expr_as_type of (
        binding_pattern_no_expr * as_custom (*tok*) * type_
    )
]

and type_constraint = [
    `Inhe_cons of (
        attribute list (* zero or more *)
      * constrained_type
      * Token.t (* ":" *)
      * possibly_implicitly_unwrapped_type
    )
  | `Equa_cons of (
        attribute list (* zero or more *)
      * constrained_type
      * [ `Equal_sign of eq_custom (*tok*) | `Eq_eq of eq_eq_custom (*tok*) ]
      * type_
    )
]

and type_constraints = (
    where_keyword (*tok*)
  * type_constraint
  * (Token.t (* "," *) * type_constraint) list (* zero or more *)
)

and type_level_declaration = [
    `Choice_import_decl of [
        `Import_decl of import_declaration
      | `Prop_decl of property_declaration
      | `Typeas_decl of typealias_declaration
      | `Func_decl of function_declaration
      | `Init_decl of init_declaration
      | `Class_decl of class_declaration
      | `Prot_decl of protocol_declaration
      | `Deinit_decl of deinit_declaration
      | `Subs_decl of subscript_declaration
      | `Op_decl of operator_declaration
      | `Prec_group_decl of precedence_group_declaration
      | `Asso_decl of associatedtype_declaration
    ]
  | `Semg_ellips of Token.t (* "..." *)
]

and type_modifiers = attribute list (* one or more *)

and type_parameter = [
    `Opt_type_param_modifs_type_param_poss_packed_opt_COLON_type of (
        type_parameter_modifiers option
      * type_parameter_possibly_packed
      * (Token.t (* ":" *) * type_) option
    )
  | `Semg_ellips of Token.t (* "..." *)
]

and type_parameter_modifiers = attribute list (* one or more *)

and type_parameter_pack = (Token.t (* "each" *) * unannotated_type)

and type_parameter_possibly_packed = [
    `Simple_id of bound_identifier
  | `Type_param_pack of type_parameter_pack
]

and type_parameters = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * type_constraints option
  * Token.t (* ">" *)
)

and typealias_declaration = (
    modifiers option
  * modifierless_typealias_declaration
)

and unannotated_type = [
    `User_type of user_type
  | `Tuple_type of tuple_type
  | `Func_type of function_type
  | `Array_type of array_type
  | `Dict_type of dictionary_type
  | `Opt_type of (
        [
            `User_type of user_type
          | `Tuple_type of tuple_type
          | `Array_type of array_type
          | `Dict_type of dictionary_type
        ]
      * Token.t (* "?" *) list (* one or more *)
    )
  | `Meta of (
        unannotated_type
      * Token.t (* "." *)
      * [ `Type of Token.t (* "Type" *) | `Prot of Token.t (* "Protocol" *) ]
    )
  | `Opaque_type of opaque_type
  | `Exis_type of existential_type
  | `Prot_comp_type of (
        unannotated_type
      * (Token.t (* "&" *) * unannotated_type) list (* one or more *)
    )
  | `Type_param_pack of type_parameter_pack
  | `Type_pack_expa of (Token.t (* "repeat" *) * unannotated_type)
]

and unary_expression = [
    `Post_exp of (directly_assignable_expression * postfix_unary_operator)
  | `Call_exp of call_expression
  | `Cons_exp of (
        [
            `Array_type of array_type
          | `Dict_type of dictionary_type
          | `User_type of user_type
        ]
      * constructor_suffix
    )
  | `Navi_exp of (
        [
            `Navi_type_exp of navigable_type_expression
          | `Exp of directly_assignable_expression
          | `Paren_type of parenthesized_type
        ]
      * navigation_suffix
    )
  | `Prefix_exp of (
        prefix_unary_operator
      * [
            `Exp of directly_assignable_expression
          | `Choice_async of [
                `Async of Token.t (* "async" *)
              | `If of Token.t (* "if" *)
              | `Switch of Token.t (* "switch" *)
            ]
        ]
    )
  | `As_exp of (directly_assignable_expression * as_operator * type_)
  | `Sele_exp of (
        Token.t (* "#selector" *)
      * Token.t (* "(" *)
      * [
            `Gett of Token.t (* "getter:" *)
          | `Sett of Token.t (* "setter:" *)
        ]
          option
      * directly_assignable_expression
      * Token.t (* ")" *)
    )
  | `Open_start_range_exp of (
        range_operator * directly_assignable_expression
    )
  | `Open_end_range_exp of (
        directly_assignable_expression * Token.t (* "..." *)
    )
]

and universally_allowed_pattern = [
    `Wild_pat of Token.t (* "_" *)
  | `Tuple_pat of tuple_pattern
  | `Type_cast_pat of type_casting_pattern
  | `Case_pat of (
        Token.t (* "case" *) option
      * user_type option
      * dot_custom (*tok*)
      * bound_identifier
      * tuple_pattern option
    )
]

and user_type = (
    simple_user_type
  * (dot_custom (*tok*) * simple_user_type) list (* zero or more *)
)

and value_argument = (
    type_modifiers option
  * [
        `Rep1_value_arg_label_COLON of
          (value_argument_label * Token.t (* ":" *)) list (* one or more *)
      | `Opt_value_arg_label_COLON_exp of (
            (value_argument_label * Token.t (* ":" *)) option
          * directly_assignable_expression
        )
    ]
)

and value_arguments = [
    `LPAR_opt_value_arg_rep_COMMA_value_arg_RPAR of
      constructor_value_arguments
  | `LBRACK_opt_value_arg_rep_COMMA_value_arg_RBRACK of (
        Token.t (* "[" *)
      * interpolation_contents option
      * Token.t (* "]" *)
    )
]

and value_pack_expansion = (
    Token.t (* "repeat" *) * directly_assignable_expression
)

and value_parameter_pack = (
    Token.t (* "each" *) * directly_assignable_expression
)

and where_clause = (where_keyword (*tok*) * directly_assignable_expression)

and while_statement = (
    Token.t (* "while" *)
  * if_condition_sequence_item
  * (Token.t (* "," *) * if_condition_sequence_item) list (* zero or more *)
  * Token.t (* "{" *)
  * statements option
  * Token.t (* "}" *)
)

and willset_clause = (
    modifiers option
  * Token.t (* "willSet" *)
  * (Token.t (* "(" *) * bound_identifier * Token.t (* ")" *)) option
  * function_body
)

and willset_didset_block = [
    `LCURL_will_clause_opt_didset_clause_RCURL of (
        Token.t (* "{" *)
      * willset_clause
      * didset_clause option
      * Token.t (* "}" *)
    )
  | `LCURL_didset_clause_opt_will_clause_RCURL of (
        Token.t (* "{" *)
      * didset_clause
      * willset_clause option
      * Token.t (* "}" *)
    )
]

type external_macro_definition = (
    Token.t (* "#externalMacro" *) * expr_hack_at_ternary_binary_call_suffix
)

type macro_head = (modifiers option * Token.t (* "macro" *))

type macro_signature = (
    function_value_parameters
  * (arrow_operator_custom (*tok*) * unannotated_type) option
)

type macro_definition = (
    eq_custom (*tok*)
  * [
        `Exp of directly_assignable_expression
      | `Exte_macro_defi of external_macro_definition
    ]
)

type global_declaration = [
    `Import_decl of import_declaration
  | `Prop_decl of property_declaration
  | `Typeas_decl of typealias_declaration
  | `Func_decl of function_declaration
  | `Init_decl of init_declaration
  | `Class_decl of class_declaration
  | `Prot_decl of protocol_declaration
  | `Op_decl of operator_declaration
  | `Prec_group_decl of precedence_group_declaration
  | `Asso_decl of associatedtype_declaration
  | `Macro_decl of (
        macro_head
      * bound_identifier
      * type_parameters option
      * macro_signature
      * macro_definition option
      * type_constraints option
    )
]

type top_level_statement = [
    `Exp of directly_assignable_expression
  | `Global_decl of global_declaration
  | `Labe_stmt of labeled_statement
  | `Throw_stmt of throw_statement
]

type source_file = (
    shebang_line option
  * (
        top_level_statement
      * (semi * top_level_statement) list (* zero or more *)
      * semi option
    )
      option
)

type semgrep_expression_ellipsis (* inlined *) = Token.t (* "..." *)

type wildcard_pattern (* inlined *) = Token.t (* "_" *)

type comment (* inlined *) = Token.t

type self_expression (* inlined *) = Token.t (* "self" *)

type await_operator (* inlined *) = Token.t (* "await" *)

type immediate_quest (* inlined *) = Token.t (* "?" *)

type unused_for_backward_compatibility (* inlined *) = [
    `Unused1 of Token.t (* "unused1" *)
  | `Unused2 of Token.t (* "unused2" *)
]

type super_expression (* inlined *) = Token.t (* "super" *)

type visibility_modifier (* inlined *) = (
    [
        `Public of Token.t (* "public" *)
      | `Priv of Token.t (* "private" *)
      | `Inte of Token.t (* "internal" *)
      | `File of Token.t (* "fileprivate" *)
      | `Open of Token.t (* "open" *)
      | `Pack of Token.t (* "package" *)
    ]
  * (Token.t (* "(" *) * Token.t (* "set" *) * Token.t (* ")" *)) option
)

type use_site_target (* inlined *) = (
    [
        `Prop of Token.t (* "property" *)
      | `Get of Token.t (* "get" *)
      | `Set of Token.t (* "set" *)
      | `Rece of Token.t (* "receiver" *)
      | `Param of Token.t (* "param" *)
      | `Setp of Token.t (* "setparam" *)
      | `Dele of Token.t (* "delegate" *)
    ]
  * Token.t (* ":" *)
)

type three_dot_operator (* inlined *) = Token.t (* "..." *)

type diagnostic (* inlined *) = Token.t

type property_behavior_modifier (* inlined *) = Token.t (* "lazy" *)

type throw_keyword (* inlined *) = Token.t (* "throw" *)

type is_operator (* inlined *) = Token.t (* "is" *)

type open_ended_range_operator (* inlined *) = Token.t (* "..<" *)

type quest (* inlined *) = Token.t (* "?" *)

type directive (* inlined *) = Token.t

type semgrep_ellipsis (* inlined *) = Token.t (* "..." *)

type dummy_alias0 (* inlined *) = multiline_comment (*tok*)

type arrow_operator (* inlined *) = arrow_operator_custom (*tok*)

type multiline_regex_literal (* inlined *) = (pat_c6c5536 * pat_27d7db1)

type async_keyword (* inlined *) = async_keyword_custom (*tok*)

type as_bang (* inlined *) = as_bang_custom (*tok*)

type eq_eq (* inlined *) = eq_eq_custom (*tok*)

type uni_character_literal (* inlined *) = (
    Token.t (* "\\" *) * Token.t (* "u" *) * pat_888b548
)

type disjunction_operator (* inlined *) = disjunction_operator_custom (*tok*)

type as_quest (* inlined *) = as_quest_custom (*tok*)

type equal_sign (* inlined *) = eq_custom (*tok*)

type dot (* inlined *) = dot_custom (*tok*)

type as_ (* inlined *) = as_custom (*tok*)

type conjunction_operator (* inlined *) = conjunction_operator_custom (*tok*)

type nil_coalescing_operator (* inlined *) =
  nil_coalescing_operator_custom (*tok*)

type modifier (* inlined *) = [
    `Non_local_scope_modi of non_local_scope_modifier
  | `Loca_perm_modi of locally_permitted_modifier
]

type availability_condition (* inlined *) = (
    [
        `HASH_8da4fa1 of Token.t (* "#available" *)
      | `HASH_459dd9a of Token.t (* "#unavailable" *)
    ]
  * Token.t (* "(" *)
  * availability_argument
  * (Token.t (* "," *) * availability_argument) list (* zero or more *)
  * Token.t (* ")" *)
)

type additive_expression (* inlined *) = (
    directly_assignable_expression * additive_operator
  * directly_assignable_expression
)

type array_literal (* inlined *) = (
    Token.t (* "[" *)
  * (
        directly_assignable_expression
      * (Token.t (* "," *) * directly_assignable_expression)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

type as_expression (* inlined *) = (
    directly_assignable_expression * as_operator * type_
)

type await_expression (* inlined *) = (
    Token.t (* "await" *)
  * [
        `Exp of directly_assignable_expression
      | `Call_exp of call_expression
      | `Tern_exp of ternary_expression
    ]
)

type bitwise_operation (* inlined *) = (
    directly_assignable_expression * bitwise_binary_operator
  * expr_hack_at_ternary_binary_suffix
)

type case_pattern (* inlined *) = (
    Token.t (* "case" *) option
  * user_type option
  * dot_custom (*tok*)
  * bound_identifier
  * tuple_pattern option
)

type check_expression (* inlined *) = (
    directly_assignable_expression * Token.t (* "is" *) * type_
)

type comparison_expression (* inlined *) = (
    directly_assignable_expression * comparison_operator
  * expr_hack_at_ternary_binary_suffix
)

type conjunction_expression (* inlined *) = (
    directly_assignable_expression * conjunction_operator_custom (*tok*)
  * expr_hack_at_ternary_binary_suffix
)

type constructor_expression (* inlined *) = (
    [
        `Array_type of array_type
      | `Dict_type of dictionary_type
      | `User_type of user_type
    ]
  * constructor_suffix
)

type dictionary_literal (* inlined *) = (
    Token.t (* "[" *)
  * [
        `COLON of Token.t (* ":" *)
      | `Dict_lit_item_rep_COMMA_dict_lit_item of (
            dictionary_literal_item
          * (Token.t (* "," *) * dictionary_literal_item)
              list (* zero or more *)
        )
    ]
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

type disjunction_expression (* inlined *) = (
    directly_assignable_expression * disjunction_operator_custom (*tok*)
  * expr_hack_at_ternary_binary_suffix
)

type enum_type_parameters (* inlined *) = (
    Token.t (* "(" *)
  * (
        tuple_type_item_identifier option
      * type_
      * expression_without_willset_didset option
      * (
            Token.t (* "," *)
          * tuple_type_item_identifier option
          * type_
          * expression_without_willset_didset option
        )
          list (* zero or more *)
    )
      option
  * Token.t (* ")" *)
)

type equality_constraint (* inlined *) = (
    attribute list (* zero or more *)
  * constrained_type
  * [ `Equal_sign of eq_custom (*tok*) | `Eq_eq of eq_eq_custom (*tok*) ]
  * type_
)

type equality_expression (* inlined *) = (
    directly_assignable_expression * equality_operator
  * expr_hack_at_ternary_binary_suffix
)

type expr_hack_at_ternary_binary_call (* inlined *) = (
    directly_assignable_expression * expr_hack_at_ternary_binary_call_suffix
)

type for_statement_await (* inlined *) = (
    Token.t (* "await" *) * directly_assignable_expression
)

type if_let_binding (* inlined *) = (
    direct_or_indirect_binding
  * expression_without_willset_didset option
  * where_clause option
)

type infix_expression (* inlined *) = (
    directly_assignable_expression * custom_operator
  * expr_hack_at_ternary_binary_suffix
)

type inheritance_constraint (* inlined *) = (
    attribute list (* zero or more *)
  * constrained_type
  * Token.t (* ":" *)
  * possibly_implicitly_unwrapped_type
)

type key_path_expression (* inlined *) = (
    Token.t (* "\\" *)
  * [
        `Simple_user_type of simple_user_type
      | `Array_type of array_type
      | `Dict_type of dictionary_type
    ]
      option
  * (Token.t (* "." *) * key_path_component) list (* zero or more *)
)

type key_path_string_expression (* inlined *) = (
    Token.t (* "#keyPath" *) * Token.t (* "(" *)
  * directly_assignable_expression * Token.t (* ")" *)
)

type line_string_literal (* inlined *) = (
    Token.t (* "\"" *)
  * [ `Line_str_content of line_string_content | `Interp of interpolation ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)

type local_class_declaration (* inlined *) = (
    locally_permitted_modifiers option
  * modifierless_class_declaration
)

type local_function_declaration (* inlined *) = (
    locally_permitted_modifiers option
  * modifierless_function_declaration
)

type local_property_declaration (* inlined *) = (
    locally_permitted_modifiers option
  * modifierless_property_declaration
)

type local_typealias_declaration (* inlined *) = (
    locally_permitted_modifiers option
  * modifierless_typealias_declaration
)

type metatype (* inlined *) = (
    unannotated_type
  * Token.t (* "." *)
  * [ `Type of Token.t (* "Type" *) | `Prot of Token.t (* "Protocol" *) ]
)

type multi_line_string_literal (* inlined *) = (
    Token.t (* "\"\"\"" *)
  * [
        `Multi_line_str_content of multi_line_string_content
      | `Interp of interpolation
    ]
      list (* zero or more *)
  * Token.t (* "\"\"\"" *)
)

type multiplicative_expression (* inlined *) = (
    directly_assignable_expression * multiplicative_operator
  * directly_assignable_expression
)

type navigation_expression (* inlined *) = (
    [
        `Navi_type_exp of navigable_type_expression
      | `Exp of directly_assignable_expression
      | `Paren_type of parenthesized_type
    ]
  * navigation_suffix
)

type nil_coalescing_expression (* inlined *) = (
    directly_assignable_expression * nil_coalescing_operator_custom (*tok*)
  * expr_hack_at_ternary_binary_suffix
)

type open_end_range_expression (* inlined *) = (
    directly_assignable_expression * Token.t (* "..." *)
)

type open_start_range_expression (* inlined *) = (
    range_operator * directly_assignable_expression
)

type optional_type (* inlined *) = (
    [
        `User_type of user_type
      | `Tuple_type of tuple_type
      | `Array_type of array_type
      | `Dict_type of dictionary_type
    ]
  * Token.t (* "?" *) list (* one or more *)
)

type playground_literal (* inlined *) = (
    [
        `HASH_38ce0d0 of Token.t (* "#colorLiteral" *)
      | `HASH_34ae46a of Token.t (* "#fileLiteral" *)
      | `HASH_71f9c0e of Token.t (* "#imageLiteral" *)
    ]
  * Token.t (* "(" *)
  * bound_identifier
  * Token.t (* ":" *)
  * directly_assignable_expression
  * (
        Token.t (* "," *) * bound_identifier * Token.t (* ":" *)
      * directly_assignable_expression
    )
      list (* zero or more *)
  * Token.t (* ")" *)
)

type postfix_expression (* inlined *) = (
    directly_assignable_expression * postfix_unary_operator
)

type prefix_expression (* inlined *) = (
    prefix_unary_operator
  * [
        `Exp of directly_assignable_expression
      | `Choice_async of [
            `Async of Token.t (* "async" *)
          | `If of Token.t (* "if" *)
          | `Switch of Token.t (* "switch" *)
        ]
    ]
)

type protocol_composition_type (* inlined *) = (
    unannotated_type
  * (Token.t (* "&" *) * unannotated_type) list (* one or more *)
)

type protocol_property_declaration (* inlined *) = (
    modifiers option
  * binding_kind_and_pattern
  * type_annotation option
  * type_constraints option
  * protocol_property_requirements
)

type range_expression (* inlined *) = (
    directly_assignable_expression * range_operator
  * expr_hack_at_ternary_binary_suffix
)

type raw_string_literal (* inlined *) = (
    (
        raw_str_part (*tok*)
      * raw_str_interpolation
      * raw_str_continuing_indicator (*tok*) option
    )
      list (* zero or more *)
  * raw_str_end_part (*tok*)
)

type selector_expression (* inlined *) = (
    Token.t (* "#selector" *)
  * Token.t (* "(" *)
  * [ `Gett of Token.t (* "getter:" *) | `Sett of Token.t (* "setter:" *) ]
      option
  * directly_assignable_expression
  * Token.t (* ")" *)
)

type semgrep_deep_ellipsis (* inlined *) = (
    Token.t (* "<..." *) * directly_assignable_expression * custom_operator
)

type try_expression (* inlined *) = (
    try_operator
  * [
        `Exp of directly_assignable_expression
      | `Bin_exp of binary_expression
      | `Call_exp of call_expression
      | `Tern_exp of ternary_expression
    ]
)

type tuple_expression (* inlined *) = (
    Token.t (* "(" *)
  * (bound_identifier * Token.t (* ":" *)) option
  * directly_assignable_expression
  * (
        Token.t (* "," *)
      * (bound_identifier * Token.t (* ":" *)) option
      * directly_assignable_expression
    )
      list (* zero or more *)
  * Token.t (* ")" *)
)

type type_pack_expansion (* inlined *) = (
    Token.t (* "repeat" *) * unannotated_type
)

type non_binding_pattern_with_expr (* inlined *) = (
    [
        `Univ_allo_pat of universally_allowed_pattern
      | `Exp of directly_assignable_expression
    ]
  * Token.t (* "?" *) option
)

type macro_declaration (* inlined *) = (
    macro_head
  * bound_identifier
  * type_parameters option
  * macro_signature
  * macro_definition option
  * type_constraints option
)

type extra = [
    `Comment of Loc.t * comment
  | `Multiline_comment of Loc.t * multiline_comment
  | `Directive of Loc.t * directive
  | `Diagnostic of Loc.t * diagnostic
]

type extras = extra list
